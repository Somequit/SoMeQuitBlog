# 第一章. 手写简易 Spring（一）

代码位置：/Users/gusixue/development/my_workspace/spring-boot/easy-spring

## 1. Spring Bean 容器是什么

* Spring 定义的用于存放与管理对象的配置、生命周期与依赖的容器
* 配置：单例还是多例
* 生命周期：统一的流程，实例化、属性填充、初始化、业务使用、销毁
* 依赖：生命周期的属性填充


## 2. Spring Bean 容器流程

* 基础流程
* 定义：接口 BeanDefinition、接口 BeanFactory
    * BeanDefinition：定义 Bean 的实例信息的接口
* 注册：对象的 id 与地址存放到 HashMap
    * BeanFactory：注册与获取 Bean 的**根接口**
* 获取：根据 id 获取 HashMap 的对象地址
    * BeanFactory：注册与获取 Bean 的**根接口**

![easy-spring（一）.jpg](:/eff69b77938f4945b50a29d19950a0da)


### 1. 核心抽象类 AbstractBeanFactory

1.  抽象类 AbstractBeanFactory 实现了 getBean 方法：获取 Bean 对象
    * 接口 BeanFactory 定义了 getBean 方法
    * 抽象类 AbstractBeanFactory 使用了模板方法模式
2.  实现类 DefaultSingletonBeanRegistry 实现了 getSingleton 方法：获取单例 Bean 对象
    * 接口 SingletonBeanRegistry 定义了 getSingleton 方法
3.  实现类 DefaultSingletonBeanRegistry 实现了 addSingleton(String beanName, Object singletonObject) 方法：注册单例 Bean 对象
    * 他自己定义的 addSingleton 方法

Spring 源码：
![AbstractBeanFactory_relation.png](:/7b28b5bc7b254c0a87f3bea22b0065c4)


### 2. 核心实现类 DefaultListableBeanFactory

1.  抽象类 AbstractAutowireCapableBeanFactory 实现了 createBean(String beanName, BeanDefinition beanDefinition) 方法：创建 Bean 对象
    * 依赖了 BeanDefinition 接口
    * 抽象类 AbstractBeanFactory 定义了 createBean(String beanName, BeanDefinition beanDefinition) 方法
2.  实现类 DefaultListableBeanFactory 实现了 getBeanDefinition(String beanName) 方法：获取 BeanDefinition 对象的
    * 依赖了 BeanDefinition 接口
    * 抽象类 AbstractBeanFactory 定义了 getBeanDefinition(String beanName) 方法
3.  实现类 DefaultListableBeanFactory 实现了 registerBeanDefinition(String beanName, BeanDefinition beanDefinition) 方法：注册 BeanDefinition 对象
    * 接口 BeanDefinitionRegistry 定义了 registerBeanDefinition(String beanName, BeanDefinition beanDefinition) 方法

Spring 源码：
![DefaultListableBeanFactory_relation.png](:/488994c1c7bf45eab4ca23195ecc6162)


### 3. 核心接口 InstantiationStrategy

* 抽象类 AbstractAutowireCapableBeanFactory 定义：使用 JDK 还是 Cglib 实例化带参 Bean 对象
* 核心接口 InstantiationStrategy 定义：instantiate(BeanDefinition beanDefinition, String beanName, Constructor ctor, Object\[] args) throws BeansException; 实例化对象、无论是否带参
	* 策略模式，根据传入参数自动选择哪个算法模板
* 实现类 SimpleInstantiationStrategy 实现：instantiate 方法，使用 JDK 反射创建 Bean 对象（无论是否带参）
* 实现类 CglibSubclassingInstantiationStrategy 实现：instantiate 方法，使用 Cglib 代理实例化 Bean 对象（无论是否带参）
	* Cglib 代理是一种代理模式，此外还有 Proxy 的动态代理，直接使用的静态代理
	* Cglib 代理是基于字节码框架 ASM 实现
	* net.sf.cglib.proxy.NoOp：在 Cglib 使用回调时把方法调用直接委派到父类实现（或者说传入对象直接调用方法），具体使用
		* 创建代理类（如：UserDao$$EnhancerByCGLIB$$f5cf8a20），代理类继承父类同时不去重写父类对应方法，调用方法时直接调用父类的方法


### 4. 核心实现类 AbstractAutowireCapableBeanFactory

* 实现类 PropertyValue 定义了：Bean 对象的属性名与与数据
* 实现类 PropertyValues 封装了：PropertyValue
* 实现类 BeanDefinition 定义了：注入的属性类 PropertyValues
* 实现类 AbstractAutowireCapableBeanFactory 实现了：在创建 Bean 对象后注入依赖  applyPropertyValues 的方法
* 工具类 BeanReference 定义了：它在依赖注入时属于一个 Bean 对象
* **注意此时并未考虑循环依赖的问题**


### 5. 总结

* 总结：
	* 系统设计通常是通过接口、抽象类、继承与实现，隔离类的功能职责和作用范围
	* Spring 内部将 Bean 对象拆分放入 BeanDefinition，方便统一管理



## 3. 我的代码结构

### 1. 我的调用类图（模拟 Spring 源码）


![easy-spring（一）2.png](:/71abcc6f93594860bbfeb17b7a519c0e)



### 2. 我的代码结构（模拟 Spring 源码）

```
.
└── beans
    ├── BeansException.java
    ├── PropertyValue.java
    ├── PropertyValues.java
    └── factory
        ├── BeanFactory.java
        ├── config
        │   ├── BeanDefinition.java
        │   ├── BeanReference.java
        │   └── SingletonBeanRegistry.java
        └── support
            ├── AbstractAutowireCapableBeanFactory.java
            ├── AbstractBeanFactory.java
            ├── BeanDefinitionRegistry.java
            ├── CglibSubclassingInstantiationStrategy.java
            ├── DefaultListableBeanFactory.java
            ├── DefaultSingletonBeanRegistry.java
            ├── InstantiationStrategy.java
            └── SimpleInstantiationStrategy.java
.
└── test
    ├── ApiTest.java
    └── bean
        ├── UserController.java
        ├── UserDao.java
        └── UserService.java
```
