# 第二章. 具体集合

## 1. 数组 —— ArrayList

* 循环删除 List 中的元素
	* 工程式写法（可读性、易维护）：新建一个 List ，循环放入不删除的元素
	* 普通 for 循环倒序删除
	* 迭代器循环，迭代器调用 remove 方法删除
	* stream filter 过滤
	* 其他删除方式可能出现：未删除干净、数组下标越界异常、并发修改异常、


## 2. 链表 —— LinkedList

绝对不应该使用这种让人误解的随机访问方法来遍历链表。下面这段代码的效率极低:
for (int i=0; i < list.sizeO ;i++) 
do something with list.get(i);
每次査找一个元素都要从列表的头部重新开始搜索。LinkedList对象根本不做任何缓存位置信息的操作。


## 3. 散列集 —— HashSet

在 Java 中,散列表用链表数组实现。每个列表被称为桶 (bucket) (参看图 9-10 )。要想査找表中对象的位置,就要先计算它的散列码,然后与桶的总数取余,所得到的结果就是保存这个元素的桶的索引。


## 4. 树集 —— TreeSet

排序是用树结构完成的(当前实现使用的是红黑树
要使用树集,必须能够比较元素。这些元素必须实现 Comparable接口，或者构造集时必须提供一个 Comparator


## 5. 优先队列 —— PriorityQueue

无论何时调用 r em ove方法,总会获得当前优先级队列中最小的元素。
优先级队列并没有对所有的元素进行排序。如果用迭代的方式处理这些元素,并不需要对它们进行排序。优先级队列使用了一个优雅且高效的数据结构,称为堆(heap)。堆是一个可以自我调整的二叉树,对树执行添加 (add)和删除(r em or e) 操作,可以让最小的元素移动到根,而不必花费时间对元素进行排序。
使用优先级队列的典型示例是任务调度。每一个任务有一个优先级,任务以随机顺序添加到队列中。每当启动一个新的任务时,都将优先级最高的任务从队列中删除(由于习惯上将 1 设为“最高”优先级,所以会将最小的元素删除)


## 6. 映射 —— Map

![MapKeyValueNull.png](:/5d1736d0dab547dabf274b6aa21274d8)

ConcurrentHashMap 不支持 null 键和 null 值
任何 Map 类集合中，都要尽量避免 K/V 设置为 null 值

集合框架不认为映射本身是一个集合。(其他数据结构框架认为映射是一个键 /值对集合,或者是由键索引的值集合。) 不过,可以得到映射的视图( View)—这是实现了Collection接口或某个子接口的对象。
有 3 种视图:键集、值集合(不是一个集) 以及键 /值对集。键和键 /值对可以构成一个集,因为映射中一个键只能有一个副本。下面的方法: 
Set\<K\> keySet() （keySet不是 HashSet 或 TreeSet，而是一个实现 Set 接口的类对象,这个类的方法对原映射进行操作。这种集合称为视图。）
Collection\<V\> values0 
Set\<Map.Entry\<K, V\>\> entrySet()

如果在键集视图上调用迭代器的 r em ove方法,实际上会从映射中删除这个键和与它关联的值。不过,不能向键集视图增加元素。另外,如果增加一个键而没有同时增加值也是没有意义的。如果试图调用 add 方法,它会抛出一个 U nsuppor t edO per at i onExcept i on。条目集视图有同样的限制,尽管理论上增加一个新的键 /值对好像是有意义的。


## 7. 弱散列映射 —— WeakHashMap

设计 W eakH ashM ap类是为了解决一个有趣的问题。如果有一个值,对应的键已经不再使用了,将会出现什么情况呢 ? 假定对某个键的最后一次引用已经消亡,不再有任何途径引用这个值的对象了。但是,由于在程序中的任何部分没有再出现这个键,所以,这个键 /值对无法从映射中删除。为什么垃圾回收器不能够删除它呢 ? 难道删除无用的对象不是垃圾回收器的工作吗?
遗憾的是,事情没有这样简单。垃圾回收器跟踪活动的对象。只要映射对象是活动的, 其中的所有桶也是活动的,它们不能被回收。因此,需要由程序负责从长期存活的映射表中删除那些无用的值。或者使用 W eakH ashM ap完成这件事情。当对键的唯一引用来自散列条目时,这一数据结构将与垃圾回收器协同工作一起删除键 /值对。
下面是这种机制的内部运行情况。W eakH ashM ap 使用弱引用 ( w eak r ef er ences)保存键。
W eakRef er ence 对象将引用保存到另外一个对象中,在这里,就是散列键。对于这种类型的对象,垃圾回收器用一种特有的方式进行处理。通常,如果垃圾回收器发现某个特定的对象已经没有他人引用了,就将其回收。然而,如果某个对象只能由 W eakRef er ence 引用,垃圾回收器仍然回收它,但要将引用这个对象的弱引用放人队列中。W eakH ashM ap将周期性地检查队列,以便找出新添加的弱引用。一个弱引用进人队列意味着这个键不再被他人使用,并且已经被收集起来。于是,W eakH ashM ap 将删除对应的条目。

## 8. 链接散列集与映射 —— LinkedHashSet 与 LinkedHashMap

用来记住插入元素项的顺序。这样就可以避免在散歹IJ表中的项从表面上看是随机排列的。当条目插入到表中时,就会并人到双向链表中
accessOrder 为 true 则代表链接散列映射将用访问顺序,而不是插入顺序,对映射条目进行迭代。每次调用 get或put, 受到影响的条目将从当前的位置删除,并放到条目链表的尾部(只有条目在链表中的位置会受影响,而散列表中的桶不会受影响。一个条目总位于与键散列码对应的桶中)。
访问顺序对于实现高速缓存的“最近最少使用”原则十分重要。例如,可能希望将访问频率高的元素放在内存中,而访问频率低的元素则从数据库中读取。当在表中找不到元素项且表又已经满时,可以将迭代器加入到表中,并将枚举的前几个元素删除掉。这些是近期最少使用的几个元素。


## 9. 枚举集与映射 —— EnumSet

一个枚举类型元素集的高效实现。由于枚举类型只有有限个实例,所以Enum Set内部用位序列实现。如果对应的值在集中,则相应的位被置为 1。
Enum Set类没有公共的构造器。可以使用静态工厂方法构造这个集：EnumSet


## 10. 标识散列映射 —— IdentityHashMap

在这个类中,键的散列值不是用 hashCode 函数计算的,而是用 System.identityHashCode 方法计算的。这是 Object.hashCode 方法根据对象的内存地址来计算散列码时所使用的方式。而且,在对两个对象进行比较时,IdentityHashMap 类使用==, 而不使用 equals。
也就是说,不同的键对象,即使内容相同,也被视为是不同的对象。在实现对象遍历算法(如对象串行化)时,这个类非常有用,可以用来跟踪每个对象的遍历状况。