# 第一章. 集合框架设计

## 1. 接口与实现隔离 —— 使用多态

与现代的数据结构类库的常见情况一样,Java 集合类库也将接口 ( i nt er f ace) 与 实 现(i m pl em ent at i on) 分离。
当在程序中使用队列时,一旦构建了集合就不需要知道究竟使用了哪种实现。因此,只有在构建集合对象时,使用具体的类才有意义。可以使用接口类型存放集合的引用。


## 2. 迭代器

Col l ect i on 接口扩展了 I t er abl e 接口。因此,对于标准类库中的任何集合都可以使用“f or each”循环。
“f oreach”循环可以与任何实现了 I t er abl e 接口的对象一起工作,这个接口只包含一个抽象方法：Itreator\<E\> iterator();

对 next方法和 r em ove 方法的调用具有互相依赖性。如果调用 r em ove 之前没有调用 next将是不合法的。如果这样做,将会抛出一个 I l l egal St at eExcept i on异常。
Li st l t er at or接口有两个方法,可以用来反向遍历链表。

在用“光标”类比时要格外小心。r em ove 操作与 BA CK SPA CE 键的工作方式不太一样。在调用 next之后,r em ove方法确实与 BA CK SPA CE 键一样删除了迭代器左侧的元素。但是,如果调用 pr evi ous就会将右侧的元素删除掉,并且不能连续调用两次r em oveo add 方法只依赖于迭代器的位置,而 r em ove 方法依赖于迭代器的状态。


## 3. fail-fast 机制

通过非检查异常暴力反馈出来
如果在某个迭代器修改集合时,另一个迭代器对其进行遍历,一定会出现混乱的状况。例如,一个迭代器指向另一个迭代器刚刚删除的元素前面,现在这个迭代器就是无效的,并且不应该再使用。链表迭代器的设计使它能够检测到这种修改。如果迭代器发现它的集合被另一个迭代器修改了,或是被该集合自身的方法修改了,就会抛出一个Concur r ent M odi f i cat i onExcept i on异常。
有一种傅单的方法可以检测到并发修改的问题。集合可以跟踪改写操作(诸如添加或删除元素)的次数。每个迭代器都维护一个独立的计数值。在每个迭代器方法的开始处检查自己改写操作的计数值是否与集合的改写操作计数值一致。如果不一致,抛出一个 ConcurrentModificationException （并发修改）异常。
对于并发修改列表的检测肴一个奇怪的例外。链表只负责跟踪对列表的结构性修改,例如,添加元素、删除元素。set 方法不被视为结构性修改。可以将多个迭代器附加给一个链表,所有的迭代器都调用 set 方法对现有结点的内容进行修改。在本章后面所介绍的Collections 类的许多算法都需要使用这个功能。


## 4. 实用方法

当然,如果实现 Collection 接口的每一个类都要提供如此多的例行方法将是一件很烦人的事情。为了能够让实现者更容易地实现这个接口,Java 类库提供了一个类 AbstractCollection, 它将基础方法 size 和 iterator 抽象化了,但是在此提供了例行方法。


## 5. 抽象类

Java SE 6 引人了接口 N avi gabl eSet和 N avi gabl eM ap, 其中包含一些用于搜索和遍历有序集和映射的方法。(理想情况下,这些方法本应当直接包含在 Sor t edSet和 Sor t edM ap 接口中。)Tr eeSet和 Tr eeM ap类实现了这些接口。

RandomAccess：
为了避免对链表完成随机访问操作,Java SE 1. 4 引入了一个标记接口 Random A ccess。
这个接口不包含任何方法,不过可以用它来测试一个特定的集合是否支持高效的随机访问:
如果提供的列表没有实现 Random A ccess接口,shuf f l e方法将元素复制到数组中,然后打乱数组元素的顺序,最后再将打乱顺序后的元素复制回列表。


## 6. 元素比较

* Comparable 接口
	* 自己和自己比、自营性质的比较器
	* 类自己实现 Comparable 接口，重写 compareTo(T o) 方法，使用 this 与 o 进行比较
	* 根据开闭原则，最好不要对自己已经交付的类进行修改，或者是他人提供的类，所以最好在外部定义比较器
* Comparator 接口
	* 第三方比较器、平台性质的比较器
	* 外部类实现 Comparator 接口，重写compare(T o1, T o2) 方法，使用 o1 与 o2 进行比较
	* 可以根据使用自定义比较器与规则
*  约定俗成，不管是 Comparable还是 Comparator，小于的情况返回 -1，等于的情况返回 0 ，大于的情况返回 1

Arrays.sort() 采用的是 TImeSort 算法，是归并排序（Merge Sort）与插入排序（Insertion Sort）优化后的排序算法
* 归并排序的分段不再从单个元素开始，而是每次先查找当前最大的排序好的数组片段
* 引入了二分排序优化插入排序，

Object 类定义中对 hashCode 和 equals 要求
1. 如果两个对象的 equals 结果相同，则 hashCode 也必须是相同的
2. 任何时候重写 equals ，都必须同时重写 hashCode