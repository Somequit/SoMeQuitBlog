# 第一章. 并发基础

* 进程与线程区别
	* 进程是资源分配的最小单位，线程是 CPU 调度的最小单位
	* 进程间资源是隔离的，线程间有共享对象
	* 创建、切换与销毁一个线程比操作进程开销小
* 线程状态
	* NEW（新建）
	* RUNNABLE（可运行）
	* BLOCKED（阻塞）
	* WAITING（等待）
	* TIMED_WAITTING（计时等待）
	* TERMINATED（终止）
* 线程属性
	* 中断线程
	* 守护线程
	* 线程名
	* 未捕获异常的处理器：实现 Thread.UncaughtExceptionHandler 接口



* 实现多线程的四种方法
* 继承 Thread 类、实现 run()，无返回值
	* 很少使用，因为要把并发运行任务和运行机制解耦
```Java
class MyThread extends Thread {
    public void run() {
        // task code
    }
}
MyThread thread = new MyThread();
thread.start();
```
* 实现 Runnable 接口的 run()，无返回值
```Java
Runnable r = () -> {
	// task code
};
Thread thread = new Thread(r);
thread.start();
```
* 实现 Callable 接口通过 FutureTask 包装器来创建 Thread 线程，有返回值、可抛异常
```Java
private static void FutureTaskTest() {
    Callable<Integer> task = () -> {
        return 1;
    };
    FutureTask<Integer> futureTask = new FutureTask<>(task);
    Thread t = new Thread(futureTask);
    t.start();

		// do Something

    try {
				 // 阻塞方法、直到计算完成
        futureTask.get();
    } catch (InterruptedException e) {
		    System.out.println("InterruptedException");
        e.printStackTrace();
		// 其他异常都会转化
    } catch (ExecutionException e) {
				 System.out.println("ExecutionException");
        e.printStackTrace();
    }
}
```
* 使用 Callable 接口传递给一个执行器 Executors，有返回值、可抛异常（可能不规范、规范见线程池篇）
```Java
/**
 * 使用 Callable 接口传递给一个执行器 Executors，有返回值、可抛异常（可能不规范、规范见线程池篇）
 */
private static void ExecutorsTest() {
    Callable<Integer> task = () -> {
        return 1;
    };

    // 执行器创建固定 8 线程的线程池
    ExecutorService executor = Executors.newFixedThreadPool(8);
    // 构建完成服务，管理 Future 对象阻塞队列，其中包含已经提交的任务的执行结果，它是更有效的组织形式
    ExecutorCompletionService<Integer> pool = new ExecutorCompletionService(executor);
    pool.submit(task);

    try {
        Integer result = pool.take().get();
        System.out.println(result);
    } catch (InterruptedException e) {
        e.printStackTrace();
    } catch (ExecutionException e) {
        e.printStackTrace();
    }

    executor.shutdown();
}
```
