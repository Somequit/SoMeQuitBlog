# 第一章. 走近 Java

## 1. Java 虚拟机——JVM

* 1999 年，Sun 公司发布了 C/C++ 实现的 HotSpot Java 虚拟机（主流）。
* 它采用解释与编译混合执行的模式，其 JIT 技术采用分层编译（热点代码直接编译成机器码），极大地提升了 Java 的执行速度。
* 除此之外还有 BEA 的 JRockit 在 2008 年被并入 HotSpot，IBM 的 J9  也在 2017 年开源。


## 2. 字节码

Java 所有的指令有 200 个左右，一个字节可以存储 256 种不同的指令信息，一个这样的字节称为字节码。
JVM 在字节码上设计了一套操作码助记符，使用特殊单词来标记这些难以阅读的二进制字节码。
在 IDEA 中找到对应 class ，然后拖进 Terminal，使用 javap -c xxx.class 反编译

1. 加载或存储指令：在某个栈帧中，通过指令操作数据在虚拟机栈的局部变量表与操作栈之间来回传输
	1. 将局部变量加载到操作栈中
		* ILOAD：I 代表将 int 类型的局部变量，LOAD 代表压入栈
		* ALOAD：A 代表将对象引用的局部变量，LOAD代表压入栈
	2. 从操作栈顶存储到局部变量表，如 ISTORE、ASTORE
	3. 将常量加载到操作栈顶（高频）
		* ICONST 加载的是 -1 ~ 5 的数
		* BIPUSH，即 Byte Immediate PUSH，加载 -128 ~ 127 的数
		* SIPUSH，即 Short Immediate PUSH，加载 -32768 ~ 32767 的数
		* LDC，即 Load Constant，加载 -2147483648 ~ 2147483647 或者是字符串
2. 运算指令
	1. 对两个操作栈帧上的值进行运算，并把结果写入操作栈顶，如 IADD、IMUL 等
3. 类型转换指令
	1. 显式转换两种不同的数值类型，如 I2L、D2F 等
4. 对象创建与访问指令：根据类进行对象的创建、初始化、方法调用相关指令
	1. 创建对象指令，如 NEW、NEWARRAY 等。
	2. 访问属性指令，如 GETFIELD、PUTFIELD、GETSTATIC 等。
	3. 检查实例类型指令。如 INSTANCEOF、CHECKCAST 等。
5. 操作栈管理指令
	1. 出栈操作，如 POP 即一个元素、POP2 即两个元素。
	2. 复制栈顶元素并压入栈，如 DUP。
6. 方法调用与返回指令
	1. INVOKEVIRTUAL 指令，调用对象的实例方法。
	2. INVOKESPECIAL 指令，调用实例初始化方法、私有方法、父类方法等。
	3. INVOKESTATIC 指令，调用类静态方法。
	4. RETURN 指令，返回 VOID 类型。
7. 同步指令
	1. ACC_SYNCHRONIZED 标志同步方法，指令集中有 MONITORENTER 和 MONITOREXIT 支持 synchronized 语义。

## 3. 字节码的执行

* **字节码必须通过类加载过程加载到 JVM 环境后，才可以执行。**
* 主流 JVM 默认使用 JIT 编译与解释混合执行。
	* 优势在于解释器在启动时先解释执行，省去编译时间
	* 随着时间推进，JVM 通过热点代码统计分析，识别高频的方法调用、循环体、公共模块等，判断是否超过阈值
	* 基于强大的 JlT 动态编译技术，后台执行编译转化为机器码，存入 Code Cache，直接交给 CPU 执行
* 机器在热机状态可以承受的负载要大于冷机状态（同启动时），如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。
* 在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的 1/8。
* 原因是由于刚启动的 JVM 均是解释执行，还没有进行热点代码统计和 JIT 动态编译，可能导致机器启动之后发布成功的服务器宕机。