# 第一章. 计算机基础

## 1. 计算机的整数以补码展示

1 bit 就是 1 位，简称 b；8 个 bit 组成 1 个字节，即 1 个 Byte ，简称 B；1024 个 Byte 组成 KB；其余依次推类。

---

整数在计算机中均是用**补码**表示的
* 正数补码、源码与反码一样
* 负数的补码是、对应正数原码取反，然后再加 1 ，符号位置为 1
* 0 没有正负之分，就算使用 -0 、补码表示也还是 0
* 好处是减法也能使用加法器实现。

常用的二进制运算有移位与位运算符；他们仅能操作整型（32 位）和长整型（64 位）
移位运算有三类：

* <<
	* 符号位参与运算，正负符号位均补0
	* 正负都相当于乘 2
	* 整型（32位）：<< 33 与 << 1 与 << -31 相等，(+ 32) mod 32
	* 长整型（64位）：<< 65 与 << 1 与 << -63 相等，(+ 64) mod 64
* \>>
	* 符号位参与运算，正数高位补0，负数高位补1
	* 正负都相当于除 2下取整（变小），**负数不能使用右移位代替除 2**
	* 整型与长整型一样要 mod
	* 负数 x 除以 2 并向下取整才可以写为 ( x + 1 ) > > 1，正负 x 除以 2 并向上取整都可以写为 ( ( x − 1 ) > > 1 ) + 1
* \>>>
	* 符号位参与运算，正负符号位均补0
	* 正数相当于除 2
	* 整型与长整型一样要 mod

位运算符有四类：

* &（按位与）
	* 两者为 1 才是 1，true/false 运算也合法、因为底层也是1/0
	* 场景：获得 IP 网段，IP 地址与掩码 255.255.255.0 运算获取高 24 位
	* 没有短路，&& 才有短路
* | （按位或）
	* 有一者为 1 就是 1
	* 没有短路，|| 才有短路
* ~（按位取反）
	* 1 与 0 取反
* ^（按位异或）
	* 相同为 0，不同为 1
	* 场景：哈希算法中离散哈希值
	* 没有短路

精确运算

* 运算符对于计算溢出会容忍，如需要抛异常使用 Math 的方法：addExact()、subtractExact() 等
* 计算的中间过程、精度会根据寄存器截取（比如 Intel 有 80 位寄存器、而不是 64 位），因此不同机器运算结果可能不一致，如果需要精确则使用：strictfp、StrictMap 类


## 2. 浮点数

**千万不要用浮点数表金额等重要指标，要用 Long（分）、BigDecimal 或字符串**
**数据库中保存小数，禁止使用 float 或 double，推荐使用 decimal**

```Java
/**
 * 浮点数计算，控制误差
 * @author gusixue
 * @date 2023/2/5
 */
public class DoubleErrorController {

    public static void main(String[] args) {
        doubleCalculate(1.0 - 0.9, 0.9 - 0.8);
        doubleCalculate(0.8 - 0.7, 0.7 - 0.6);
        doubleCalculate(0.2 - 0.1, 0.1 - 0);
        doubleCalculate(0.3 - 0.1, 0.1 - 0);
    }

    private static void doubleCalculate(double g, double h) {
        System.out.println(g);
        System.out.println(h);
        double diff = 1e-6;
        if (Math.abs(g - h) < diff) {
            System.out.println("true");
        } else {
            System.out.println("false");
        }
    }
}
```

* 浮点数比较可以使用：**Double.equals()**
	* 底层是使用本地方法，将其转化为 LongBit 比较的
	* var1 instanceof Double && doubleToLongBits(((Double)var1).value) == doubleToLongBits(this.value);

---

计算机定义了两种小数，分别为定点数和浮点数
* 定点数整数部分和小数部分独立表示，互不干扰，应用不广
* 应用更广的是浮点数，采用科学计数法表示，由符号位、有效数字、指数组成

当前业界流行的浮点数标准是 IEEE754，该标准规定了浮点数类型：单精度（32bit）、双精度（64bit）、延伸单精度（43bit+）、延伸双精度（79bit+），后两种不常用。

* 单精度（float）
	* 4 字节
	* 无法表示零值
	* 正数取值范围：1.4e-45 到 3.4e+38
	* 负数取值范围：-3.4e+38 到 -1.4e-45
	* 6~7位有效数字即精度
	* 非默认，最后要加 f/F
* 双精度（double）
	* 8 字节
	* 无法表示零值
	* 正数取值范围：4.9e-324 到 1.798e+308
	* 负数取值范围：-1.798e+308 到 -4.9e-324
	* 15位有效数字即精度
	* 字面值常量默认取、也可以加 d/D
* 浮点数
	* 被 0 除不会抛出异常，而是返回特殊结果
	* 正无穷大：Float.POSITIVE_INFINITY，表示为 1.0f / 0.0f，可以直接 ==
	* 负无穷大：Double.NEGATIVE_INFINITY 表示为 -1.0 / 0.0，可以直接 ==
	* 非数字：NaN 表示为 0.0 / 0 或  Math.sqrt(-1)，只能使用 isNaN
---
数学中科学计数法：-4.86 * 10 ^ 11 = -4.86e11
* 符号位指正负
* 有效数字a，大于等于 1、小于 10
* 指数是 11

浮点数转二进制
* 整数部分转化：除 2 取余，逆序排列
* 小数部分转化：乘 2 取整，正序排列
* 小数转化会无限循环、代表无法精确，仅表示近似值
* 整数小数合并，小数点左移/右移到最左边那个 1 后，形成的不包含 1 的二进制就是有效数字，左/右移动的次数就是指数

浮点数使用 IEEE754 标准，对应数学的科学计数法，但顺序、称呼均不同
* 符号位，0 表正数，1 表负数
* 指数称为"阶码"，分配 8/11 位，二进制存，决定大小范围，实际存非负的移码
* 有效数字称为"尾数"，分配 23/52 位，十进制存，决定计算精度，以原码表示

---

加减运算
* 零值检测，任一数中阶码和尾数全 0，则直接得出结果
* 对阶操作，阶码小的数，小数点左移，尾数使用补码、尾数前补 0/1
* 尾数求和，对阶完成后，直接求和
* 结果规格化，小数点左移/右移，到最左边那个 1 后
* 结果舍入，对阶会丢失精度，需要将丢失的数据放到保存位，规格化后加回来再进行舍入

## 3. 字符集与乱码

**系统换行符（任意平台均可用）：System.lineSeparator()**

ASCII 码系统换行符
* 10 是 LF 即 ”\n“，UNIX 与新版 macOS 的换行符
* 13 是 CR 即"\r"，老版 macOS 的换行符
* "\r\n" 是 Windows 的换行符

---

**强烈建议不要使用 char，可以将其作为抽象类型处理**
**只有特殊字符处理时采用反斜杠“\“，否则全部使用正斜杠”/“（可看做向前走的人）**

* 字符编码是指一种规则，它将自然语言与计算机能理解的 0、1 进行配对
* ASCII 码（**字符集**）只有 1 个字节，只表示 127 个符号（有一位永远是0），用于大小写英文字母、数字、标点以及美式特殊符号
* Unicode（统一码、万国码）是一种通用（**字符集**），表示世界上大部分文字，Unicode 开始是 16 位的 UCS-2，后来扩展到 32 位的 UCS-4
* 如果按照 Unicode 规定来存储字符，那么文件将会浪费巨大，因为大量字符只占 1-2 个字节，却要用 4 个字节表示（其他全是 0），因此出现了 Unicode 的中间格式（**字符集**）、压缩方式或者说存储方式：UTF-8、UTF-16、UTF-32
	* UTF-8 使用 1-4 个字节为 Unicode 字符编码，且向下兼容 ASCII 码
	* UTF-16 使用 2 或 4 个字节，不兼容 UTF-8，它有大端序（UTF-16BE）与小端序（UTF-16LE）的区别
	* UTF-32 使用 4 个字节，UTF-32 与 UTF-16 一样有大端序和小端序之别
* UTF-8 表示中文大多 3 个字节，但中国网站少有其他文字，国家为减少数据存储空间使用2或4字节标准（**字符集**）：GB2312、GBK、GB18030
	* GB2312：16 位字符集，中国国家标准；但不兼容繁体中文
	* GBK：16 位字符集，简繁中文共存的环境，向下完全兼容 GB2312，向上支持 ISO-10646 国际标准；但不属于官方标准，很多搜索引擎都不能很好地支持GBK汉字
	* GB18030：32 位字符集，收录你能想到的文字和符号，最新国家标准；但目前支持它的软件较少
* \u0000 到 \uFFFF
	* 它在 Java 中可代表一个 char 字符，也代表 Unicode 这种字符集
	* \u 代表 Unicode 的转义序列，后面接着 4 位 16 进制数字，他会在解析代码之前被处理成可见的字符
	* String exampleStr = "你\u0022+\u0022好" 这个会输出 你好 两个字，因为 \u0022 会被会被转义成双引号
* Java 中反斜杠都是转义字符，因此如果最后需要反斜杠，就需要处理次数 * 2 个反斜杠，例如：正则匹配反斜杠需要写 4 个反斜杠
---

* 字符集如果不兼容则会造成乱码，乱码的出现场景：编码环境、网页展示、文本转换、文件读取等。数据流从底层数据库到客户端都可能出问题，为了减少麻烦，所有情况下的字符集设置最好是一致的
	* 如果出现“锟斤拷”就可以考虑 UTF-8 与 GBK 之间的转化了
	* 如果出现“�”就知道是无法兼容的字符集

```Java
String msg = "你好啊，我来自中国";
byte[] utf8Byte = msg.getBytes(Charset.forName("UTF-8"));
byte[] utf16Byte = msg.getBytes(Charset.forName("UTF-16"));

// 你好啊，我来自中国
System.out.println("UTF-8 编码，UTF-8 解码：" + new String(utf8Byte, "UTF-8"));
// ꃥꖽ諯벌釦鶥ꫤ뢭�
System.out.println("UTF-8 编码，UTF-16 解码：" + new String(utf8Byte, "UTF-16"));
// ��O`Y}UJ�bge��N-V�
System.out.println("UTF-16 编码，UTF-8 解码：" + new String(utf16Byte, "UTF-8"));
```

## 4. JDK 与 JRE 与 JVM 关系

![jdk_jre_jvm.png](/images/article/java/base/jdk_jre_jvm.png)

* **仅需要JDK即可简单开发**
* **只安装JRE能运行（.class）文件**

## 5. Java EE

* Java EE 是一系列技术标准所组成的平台，包括：
	* **Java SE**：Java 基础语言（本书介绍的都是 Java SE）
	* **Servlet** – Java 服务端程序、用于处理网络请求与返回响应数据（即业务逻辑），运行于支持 Java 的 Web 应用服务器中（如 Tomcat、Jboss）；**Web 应用服务器**：处理浏览器等 Web 客户端的请求并响应、也可以放置文件让全世界浏览及下载
	* **JDBC** – 访问关系型数据库连接的 API（Java Database Connectivity），被主流 ORM 框架 MyBatis 封装
	* **JMS** - Java 消息服务（Java Message Service）、面向消息中间件（MOM）的 API，Kafka、ActiveMQ、RabbitMQ等MQ产品实现了 JMS API
	* **JNDI** - Java 名称与目录接口、关联名称和对象（Java Naming and Directory Interface），例如在JDBC连接数据库时引用参数时、可以让参数的数据源写成 XML 配置
	* **JTA** - Java 事务 API（Java Transaction API）、可用于分布式事务
	* **JavaMail**：Java 邮件服务
	* JMX - Java Management、Java 管理扩展、核心组件是托管 Bean，Spring 可以支持 JMX
	* JAXP - Java XML 解析 API（Java API for XML Processing）
	* JSP - Java 服务器页面（Java Server Pages）
	* JSTL - Java 服务器页面标准标签库（Java Server Pages Standard Tag Library）
	* StAX - Streaming APIs for XML Parsers、读写 XML 文档的 API

	* ~~JAX-RPC - Java API for XML-Based Remote Procedure Calls、基于XML的远程过程调用接口（放在javax.xml.rpc包）~~
	* ~~JAXM - Java API for XML Messaging，构建SOAP 包和解析SOAP 包提供了重要的支持~~
	* ~~JAXR - Java API for XML Registries、多种类型注册服务进行交互的API，为Web Service服务提供注册~~
	* ~~JAX-WS - Java API for XML Web Services，JAX-RPC的后续版本，用于实现SOAP协议（随着SOA面向服务架构走红的RPC协议）,用于实现基于SOAP的Web Service~~、**但是由于过于臃肿、现已被Dubbo、Spring Cloud等替代**
	* ~~EJB - 企业级JavaBean（Enterprise Java Beans）~~，**被Spring替代**
	* ~~Applet – 可以包含在HTML页中~~，**类似JS，被JS、JQuery等替代**
	* ~~JAAS - Java 身份认证与授权服务~~，**被Spring Security、Apache Shiro替代**
	* ~~JACC - J2EE Authorization Contract for Containers、在J2EE应用服务器和特定的授权认证服务器之间定义了一个连接的协约，以便将各种授权认证服务器插入到J2EE产品中去。~~
	* ~~JAF - Java Beans Activation Framework~~
	* ~~JCA - J2EE连接器架构（J2EE Connector Architecture），支持不足~~
	* ~~JSF - Java Server Faces、管理页面UI~~

