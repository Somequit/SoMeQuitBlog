# 二. 面向对象

## 1. 面向过程与面向对象

* 面向过程
	* 传统的结构化程序设计通过设计一系列的过程（即算法）来求解问题，然后考虑存储数据的方式
	* 先要确定如何操作数据，然后再决定如何组织数据，让计算机有步骤地顺次做某件事情，是种过程化的叙事思维
	* 对于一些规模较小的问题，将其分解为过程的开发方式比较理想，因为结构相对松散，强调如何流程化地解决问题
* 面向对象（OOP）
	* 将数据放在第 1 位，然后再考虑操作数据的算法
	* 思维更强调高内聚、低藕合，先抽象模型，定义共性行为，再解决实际问题
	* 在大型软件开发过程中，发现用面向过程语言开发，软件维护，软件复用存在着巨大的困难， 代码开发变成了记流水账成为“面条”代码，模块之间互相辑合，流程互相穿插，往往牵发而动全身，而且假设给定对象的数据出错了，在整个程序中找 bug 要比、查找访问过这个数据项的少量方法痛苦的多
	* 面向对象提出一种计算机世界里解决复杂软件工程的方法论，将问题拆分成一个一个步骤，每个步骤抽象出对象，然后通过对象之间调用解决问题，从而拆解问题复杂度，从人类思维角度提出解决问题的步骤和方案
* 指令式编程
	* 几乎所有计算机的硬件都是设计来运行机器码，使用命令式的风格来写的
	* 关注实现的细节，主要是关注计算机执行的步骤，即一步一步告诉计算机先做什么再做什么
* 声明式编程
	* 数据库查询语言、正则表达式、Html 标签
	* 关注点由如何做转变为做什么，不关注对象的实现细节，只关注在执行过程中计算机应该做什么，并不关注底层具体所做了哪些事情
* 函数式编程
	* JavaScript、Java8 流式、List、Clojure
	* 是声明式编程的一部分，即只关注做什么而不是怎么做
	* 函数式一级公民、可以出现在任何地方，指的是数学中的函数、即映射关系
	* 函数可以作为一个普通对象使用，函数可以想象成一个盒子，将参数通过盒子进行转化
	* 函数式编程的特性：
		* 不可变性：函数不存在副作用，如果需要修改，需要克隆新的备份数据进行处理
		* 纯函数：始终接受一个或多个参数并计算参数并返回数据或函数的函数
		* 数据转换：对传递的数据克隆备份后，进行数据的处理，最终返回新的对象，避免副作用
		* 闭包：函数和其周围的状态（词法环境）的引用捆绑在一起形成闭包；即可在另一个作用域中调用函数的内部函数、并访问到该函数的作用域中的成员
		* 高阶函数：高阶函数是将函数作为参数或返回函数的函数
		* 递归：递归是一种函数在满足一定条件之前调用自身的技术
		* 组合：常用的混合函数，将多个对象混合为一个新的对象
		* 惰性计算：表达式不是在绑定到变量时立即计算，而是在求值程序需要产生表达式的值时进行计算

---

* 对象的三个主要特性
	* 对象的行为（behavior）—— 对象的行为是用可调用的方法定义的
	* 对象的状态（state）—— 每个对象都保存着描述当前特征的信息，对象状态的改变必须通过调用方法实现
	* 对象标识（identity）——每个对象都有一个唯一的身份（identity），状态常常也存在着差异
* 对象的这些关键特性在彼此之间相互影响着；如对象的状态影响它的行为

## 2. 面向对象/OOP 三大特征

1. **抽象**

* 《码出高效》一书明确将“抽象”作为面向对象的特性之一，支持面向对象“四大特性”的说法
* 抽象是面向对象思想最基础的能力之一，正确而严谨的**业务抽象和建模分析能力**是后续的封装、继承、多态的基础
* 在面向对象的思维中，抽象分为**归纳和演绎**
	* 归纳是从具体到本质，从个性到共性，将一类对象的共同特征进行归一化的逻辑思维过程
	* 归纳的过程中，需要抽象出对象的属性和行为的共性，难度大于演绎
	* 演绎则是从本质到具体，从共性到个性，逐步形象化的过程
	* 演绎是在已有问题解决方案的基础上，正确地找到合适的使用场景，它的错误在使用集合时比较常见，底层框架技术选型时如果有错误，则有可能导致技术架构完全不适应业务的快速发展
* 抽象是要找到属性和行为的共性，属性是行为的基本生产资料，具有固定的敏感性，不能直接对外暴露

2. **封装**
	* 封装就是把客观事务封装成抽象的类，一个类就是封装了它的数据以及操作数据行为的逻辑实体
	* 封装是在抽象基础上决定信息是否公开，以及公开等级，核心问题是以什么样的方式暴露哪些信息
	* 封装的主要任务是对属性、数据、部分内部敏感行为或复杂逻辑业务实现隐藏
	* 对属性的访问与修改必须通过定义的公共接口来进行，例如 getter/setter 方法
		* 如果类的提供方想在修改属性的 setter 方法上进行鉴权控制、日志记录，这是直接访问属性的情形中无法做到的
		* 且若是将已经公开的属性和行为直接暴力修改为 private，相关依赖模块都会编译出错
	* 封装使面向对象的世界变得单纯，对象之间的关系变得简单，耦合度变弱，**有利于维护**

3. **继承**
	* 继承是面向对象编程技术的基石，允许创建具有逻辑等级结构的类体系形成一个继承树，父类的能力通过这种方式赋予子类，让某些基础模块可以被直接**复用**、间接复用或增强复用
	* 继承的过程就是一般到特殊的过程
	* 继承把代码变得更有层次感，更有扩展性，为多态打下语法基础
	* 继承是 is-a 关系，**判断标准即是否符合里氏代换原则**
	* 我们传递的理念是谨慎使用继承，认清继承滥用的危害性，即方法污染和方法爆炸
		* 方法污染是指父类具备的行为，通过继承传递给子类，子类并不具备执行此行为的能力
		* 方法爆炸是指继承树不断扩大，由于方法众多，部分方法并非与当前类的功能定位相关，很容易在实际编程中产生选择困难症，或者某些方法签名非常相似，导致调用错误
	* 提倡组合优先原则来扩展类的能力，即优先采用组合或聚合的类关系来复用其他类的能力（实现接口），而不是继承

4. **多态**

* 多态是指同一操作作用于不同的对象，会有不同的解释，产生不同的执行结果

1. **编译时多态**：方法的重载（方法名称是相同的，但是参数类型或参数个数是不相同的、即方法签名不同，是水平方向上行为的不同实现）是**静态绑定**
2. **运行时多态**：程序定义的对象引用、所指向的具体类型，在运行期间才确定，属于**动态绑定**
	* 使用条件是：继承、重写（子类继承父类/实现接口时，保持方法签名完全相同，实现不同的方法体，是垂直方向上行为的不同实现）与向上转型
	* 使用方法例子：多子类继承父类/实现接口，子类重写方法，子类上转型成父类/接口组成集合，调用方法时需要在运行时、才能确认具体执行的事哪个子类的方法
3. 程序设计（不指定 Java）中的多态其实还包括参数多态，比如 Java 的泛型

* 多态根据运行时的实际对象类型，同一个方法产生不同的运行结果，使同一个行为具有不同的表现形式
* 多态式的不同内部行为的对象、共享相同的外部接口，多态也提升了对象的扩展能力和运行时的丰富想象力
* 严格意义上来说，多态并不是面向对象的一种特质，而是一种由继承行为衍生而来的进化能力而已

## 3. 面向对象五大原则

面向对象开发最大的好吃是，创建易用、易扩展、易维护的代码，罗伯特在21世纪提出了以下五大原则：S.O.L.I.D，使得写出易维护与扩展的代码变得更加的可能

|     | S.O.L.I.D                            | 原则名称    |
| --- | ------------------------------------ | ---------- |
| SRP	| The Single Responsibility Principle	| 单一责任原则 |
| OCP	| The Open Closed Principle							| 开放封闭原则 |
| LSP	| The Liskov Substitution Principle    | 里氏替换原则 |
| ISP	| The Interface Segregation Principle  | 接口隔离原则 |
| DIP	| The Dependency Inversion Principle   | 依赖倒置原则 |

1. 单一责任原则
	* 单个类变化的原因应该只有一个
	* 即让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类
	* 如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力
	* 单一职责原则其实是高内聚、低耦合在面向对象上的引申
> 高内聚、低耦合是软件工程的概念，是判断软件设计好坏的标准，目的是加强程序模块的可重用性和移植性
> 
> 内聚是模块内部功能的描述，好的内聚是指一个模块只做一件事，引起模块变化的只有单一的因素；耦合是模块之间联系的度量，低耦合是指模块之间通过接口联系的复杂度很低

* 实际案例
* 一对一视频聊有三中场景，执行流程均相同，但是计费规则等业务不同；抽象父类定义执行顺序；三种场景：一对一、直播转向、速配，直接继承父类处理规则，然后实现自己具体的计费规则
	* 榜单缓存使用了 Redis 的 zset 数据结构，其中 score 字段不仅用于排序，还用于返回客户端信息，正常情况没有问题，但是突然来了紧急需求是修改排序规则，此时修改 score 就导致了返回客户端的信息出错；这个例子看出 score 只做排序即可，不要用于其他用途

2. 开放封闭原则
	* 类应该对扩展开放，对修改关闭
	* 扩展就是添加新功能的意思，要求在添加新功能时不需要修改代码
	* 符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码
	* 实现开闭原则的核心是、面向抽象编程（抽象类、接口），通过继承和多态、让子类重写父类的方法从而扩展新功能，又因为抽象是稳定的、所以固定的抽象就对可以看做对修改关闭了
	* 需求总是变化的，而开闭原则就是既满足变化的需求、又保证内部封闭体系的稳定

* 实际案例
	* 榜单的新需求与以前的榜单处理规则有变化，以前使用的模板方法设计模式
		* 新规则要么修改旧父类，要么新写父类，要么扩展旧父类
		* 最好的办法是扩展旧父类，因为大部分规则一致，仅仅有一点点变化，但是不能修改旧父类，否则会影响旧功能
		* 继承旧父类，然后新写不同的流程

3. 里氏替换原则
	* 继承必须确保父类所拥有的性质在子类依然成立
	* 这一思想体现了对继承机制的约束规范，这约束反过来是不能成立的
	* 子类需要能够当成父类来使用，并且需要比父类更特殊

4. 接口隔离原则
	* 使用多个专门的接口比使用单一的总接口要好
	* 接口的功能应该是高内聚的，一个类依赖另一个类应该建立在最小接口上，不要强迫依赖不用的方法， 这是一种接口污染
	* 实现接口必然要接收并实现接口所有的方法与属性，单一总接口会导致、客户接收了不属于它的方法，这在设计上是一种浪费，而且修改胖接口也会出现一连串的问题

* 实际案例
	* 设计返回群聊信息接口，可以一个客户端页面设计一个接口，也可以一张表/缓存设计一个接口
		* 如果一个页面设计一个接口，客户端机器只需要调用一次、极其方便，但服务端 Controller 层调用过多 Service 层信息，并产生大量的重复处理
		* 一张表/缓存/ Service 设计一个接口，服务端 Controller 层会特别简洁，但客户端则需要按需并发调用

5. 依赖倒置原则
	* 高层模块不应该依赖于低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象
	* 高层模块包含一个应用程序中重要的策略选择和业务模块，需要保证低层模块的改动不会影响到高层模块
	* 依赖于抽象意味着：
		* 任何类都不应该从具体类派生，而应该继承抽象类或者实现接口
		* 任何方法都不应该覆写它的任何基类中的已经实现的方法

* 实际案例
	* Spring 的 IOC（控制反转） 使用的就是依赖倒置原则，被注入对象不要依赖于被依赖对象，二者都被 Spring Service Provider（IOC 容器） 统一管理

## 4. 其他常见原则

|     |                                   | 原则名称    |
| --- | --------------------------------- | ---------- |
| LOD	| The Law of Demeter	              | 迪米特法则  |
| CRP	| The Composite Reuse Principle	    | 合成复用原则 |
| CCP	| The Common Closure Principle      | 共同封闭原则 |
| SAP	| The Stable Abstractions Principle | 稳定抽象原则 |
| SDP	| The Stable Dependencies Principle | 稳定依赖原则 |

1. 迪米特法则
	* 最少知道原则（Least Knowledge Principle，简写 LKP）
	* 不和陌生人说话，一个对象应当对其他对象有尽可能少的了解
	* 减少类之间的耦合

2. 合成复用原则
	* 尽量使用对象组合，而不是通过继承来达到复用的目的

3. 共同封闭原则
	* 一起修改的类，应该组合在一起（同一个包里）
	* 如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭）

4. 稳定抽象原则
	* 最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比

5. 稳定依赖原则
	* 包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性

## 5. Java “白皮书” 的关键术语

* 可移植性：除去用户界面、数据类型、有关运算以及 Java 类库都不依赖操作系统，具有平台独立性，**字符串采用标准的Unicode格式存储**
* 体系结构中立：Java 被编译成体系结构中立的字节码文件，该文件仅被 Java 运行时系统（JVM）执行，因此可在任何操作系统执行
* 简单性：Java 语法可被看做是 C++ 语法的一个“纯净“版本，但没有完全”清理“掉不适的特性
* 面向对象：重点放在数据（对象）和关系上，而面向过程的重点是放在解决问题的步骤上
* 分布式：Java 有丰富的程序库，用于处理 HTTP 和 FTP 类的 TCP/IP 协议，它通过 URL 访问网络上的对象，便捷程度就和访问本地文件一样
* **健壮性**：Java 的可靠性很强，通过编译时校验、运行时校验保证（异常），也封装指针成模型便于开发
* 安全性：Java 适用于网络/分布式环境，安全方面处理严格：防病毒、运行时溢出、内存管理、授权
* 解释型：任何移植了 Java 解释器（JVM）的机器都能运行 Java 程序
* 高性能：运行 JVM 执行 Java 肯定比操作系统执行机器码慢，但是可选执行最频繁的字节码**即时编译**（运行时翻译为本地机器码与内联）
* 多线程：Java 在当时很超前，在多线程方面表现得很出色
* 动态性：Java 库中可自由添加方法和实例变量，而不影响客户端

平台无关性：一次编译、到处执行，即字节码文件可以在任一平台运行
* Java 编译分为前端编译与后端编译
	* **前端编译**：源语言相关、目标无关，例如 javac 就是把 Java 源码编译成 class 字节码
	* --源代码--> 词法分析 --> 符号流--> 语法分析 --> 语法树--> 语义分析 --> 语法树--> 中间码 
	* **后端编译**：将中间码翻译成机器语言，例如 JVM 把 class 字节码翻译成二进制文件
	* --中间码--> 机器无关代码优化 --> 中间码--> 代码生成 --> 机器语言--> 机器相关代码优化 -->机器语言
* JVM 不是跨平台的，每个平台都有自己的一套 JVM 将相同的 class 字节码翻译成自己的机器语言
* 每个平台都有统一的程序存储格式—— Class 字节码文件
* Java 语言也做了跨平台努力，例如 Java 的基本数据类型与行为都是自己定义的，每个平台都一致
* JVM 仅支持 Class 字节码文件，而不关心它是什么语言编译来的

源代码（\*.java）+ JDK编译器 = 字节码文件（\*.class）
字节码（\*.class）+ JRE运行环境（包含JVM）= 系统平台

* JVM 支持的比较重要的语言：Kotlin、Groovy、Scala、JRuby、Jython、Fantom、Clojure、Rhino、Ceylon
	* Kotlin：静态类型编译语言，也可编译成 JavaScript 源码，运行效率与 Java 不相上下
	* Groovy：面向对象编程语言，可做类型推断，可做 Java 语言编写的库
	* Scala：多模式的编程、即面向对象与函数式编程，拥有良好的并行编程框架，且运行效率与 Java 相差不大

## 6. 编程语言

* 任何编程语言的结构都是顺序、条件、循环
* 任何编程语言的本质都是输入与输出
* 据不完全统计, 当前编程语言超过 1000 种，优秀的程序员至少需要掌握 3 门语言，这有助于知晓不同语言的各自特性，洞悉语言的共性和编程语言思想，跨越语言的抽象思维和架构掌控力
* 但掌握不等于精通，真正的大师，需要醉心在某种语言，不断研究、不断打磨、不断回炉，才能达到炉火纯青、登峰造极的境界