# 第一章. 函数式编程

## 1. 函数式编程两大基石

1. **Lambda/代码块/方法返回给某个数据结构，这个数据机构就是函数，函数可以来回传递、进行组合**，产生强大的编程语汇
2.  **没有共享的可变数据**


## 2. 函数式接口

* 接口只定义了**一个抽象方法**，它就是一个函数式接口，此外可以有很多**已实现的 default 方法**
* **可作为参数传入方法，可以使用 Lambda 表达式**

## 3. java.util.function 包的函数式接口
1. Supplier\<T\>：供给型，T=get() 获取
2. Consumer\<T\>：消费型，accept(T) 调用消费者
3. Predicate\<T\>：断言型，Boolean=test(T) 方法校验
4. Function\<T, R\>：方法型，R=apply(T) 执行
5. 上述四类接口可**作为参数传入**
	* 调用者使用 Lambda/方法 实现接口即可
	* 使用者直接使用 参数 执行业务
6. 由于泛型不能转化基本数据类型，为便在输入和输出都是基本类型时避免自动装箱的操作，其也提供以下的接口
![function_interface_01.png](:/943c6e6d950d43a9ba0ff0510a9b9a2b)


## 4. 行为参数化

* **将方法和 Lambda 作为一等值**，即 Java 8 增加了把**代码块/方法作为参数传递给另一个方法**的能力
	* 此代码块/方法准备好、却不执行，而是延后执行
* 具体实现**类似于设计模式中的策略模式**
	* 实现类继承需要实现的接口（ java.util.function 包下主要有以下 4 个函数式接口）
	* 实现类中实现方法使用接口中的方法配置策略
	* 实现方法需要外部传入具体的函数式接口实现具体策略
* 使用：
	* `default List.sort(Comparator<? super E> c)` 中的 Comparator 就是行为参数化
	* **java.util.function 四个函数式接口作为参数传入业务方法**，不同的业务使用 匿名内部类/Lambda 实现 行为/代码后传入，这就实现了将策略传递给业务

![parameterization.png](:/2a5cea8149354c2bbe47902ea22d4c93)